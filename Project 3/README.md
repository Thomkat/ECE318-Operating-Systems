|----------------------------------------------------|
|   Dionisis Kritsas 3210 dkritsas@uth.gr            |
|   Thomas Katraouras 3215 tkatraouras@uth.gr        |
|   Giorgos Margaritis 3356 geormargaritis@uth.gr    |
|----------------------------------------------------|



-------Οδηγίες για SLOB-------
Για να ενεργοποιήσετε τα prints, στο slob.c αλλάξτε τη γραμμή 105 σε #define PRINTS_ENABLE .
Για να τα απενεργοποιήσετε, αλλάξτε τη σε #define PRINTS_DISABLE .
Για να ενεργοποιήσετε τον First Fit, αλλάξτε την γραμμή 106 σε #define FIRST_FIT .
Για να ενεργοποιήσετε τον Best Fit, αλλάξτε την γραμμή 106 σε #define BEST_FIT .
Και στις δύο περιπτώσεις μεταγλωττίστε και εγκαταστήστε πάλι τον πυρήνα.

-------Οδηγίες για δοκιμές SLOB-------
Στη σειρά 5 μπορείτε να ορίσετε τον αριθμό iterations.
Στην σειρά 6 μπορείτε να ορίσετε τον αριθμό allocations (και free) του κάθε iteration.
Στην σειρά 7 μπορείτε να ορίσετε SMALL, MEDIUM, LARGE, ανάλογα από ποια λίστα σελίδων
θέλετε να εξυπηρετούνται τα allocations.
Περισσότερα για αυτά παρακάτω.
Τέλος, κάντε make στον φάκελο tests και τρέξτε το gather_stats (έχουμε ήδη συμπεριλάβει το .a αρχείο
της στατικής βιβλιοθήκης μας, αλλά το παράγει και το Makefile).



--------------Διαδικασία ανάπτυξης του Best Fit που ακολουθήσαμε--------------
Το σωστότερο approach θα ηταν το εξής: αναζητούμε με best fit την καλυτερη σελίδα, ύστερα αναζητούμε με
best fit σε αυτή το καλύτερο block της. Αν δεν βρεθεί, βρίσκουμε την επόμενη best fit σελίδα και επαναλαμβάνουμε τη
διαδικασία μέχρι να βρεθεί κατάλληλο block. Αυτό το approach όμως ανεβάζει κατά πολύ την πολυπλοκότητα του αλγορίθμου,
λόγω πολλών διατρέξεων, πράγμα που θα καθιστούσε το σύστημα υπερβολικά αργό. Πιο συγκεκριμένα, σε μια απόπειρα υλοποίησης
αυτής της λογικής, το boot διαρκούσε πάνω απο 30 λεπτά και το σύστημα ήταν οριακά unusable.
Έτσι, το approach μας είναι το εξής. Στην slob_alloc, καθώς διατρέχουμε τις σελίδες, διατρέχουμε ταυτόχρονα όλα τα blocks
τους και κρατάμε record για το best fit block, μεχρι να βρούμε exact fit ή να διατρέξουμε όλα τα blocks, που θα έχουμε το
προτιμότερο. Ύστερα, στην slob_page_alloc, διατρέχουμε τα blocks της καλύτερης επιλεγμένης σελίδας (η οποία σίγουρα
περιέχει το best block που βρήκαμε στην slob_alloc, το οποίο και δεσμεύεται. Σε περίπτωση που δεν βρεθεί κατάλληλο block,
δεσμεύεται νέα σελίδα και το best fit block μέσα σε αυτή. Αυτό το approach είναι ό,τι πιο κοντινό στο "σωστότερο", χωρίς
να γίνεται compromise (πολύ) η απόδοση του συστήματος.
Συγκεκριμένα: Παρατηρήσαμε ότι το σύστημα και ό,τι έχει να κάνει με δέσμευση μνήμης είναι αισθητά πιο αργά, λόγω
των αρκετών διαπεράσεων των λιστών που εκτελούνται (και στους αλγορίθμους και στην καταμέτρηση της ελέυθερης μνήμης).
Παρ' όλα αυτά, όπως αναλύουμε παρακάτω, μειώνεται ο κατακερματισμός σε σχέση με τον first fit.



--------------Διαδικασία δοκιμών του Best Fit / First Fit που ακολουθήσαμε--------------
Είδαμε μέσω των debug prints ότι πάντα δεσμεύεται το σωστό block (η περίπτωση του None, παρόλο που έχει συμπεριληφθεί σαν print,
δεν πρόκειται ποτέ να εκτυπωθεί, διότι αν δεν υπάρχει κατάλληλο block αυτό θα είχε γίνει handle στην slob_alloc όπου θα είχε δεσμευτεί
νέα σελίδα).
Στο slob.c προσθέσαμε δύο μεταβλητές, τις totalFreeSpace και totalAllocatedSpace, οι οποίες κρατούν τον συνολικό ελεύθερο χώρο στις σελίδες
και τον χώρο που έχει γίνει allocate αντίστοιχα. Επίσης προσθέσαμε δύο συναρτήσεις που επιστρέφουν αυτές τις μεταβλητές, έτσι ώστε να
μπορούμε να τις επιστρέφουμε από τα system calls. Δημιουργήσαμε και το slob.h, το οποίο κρατά τους ορισμούς αυτών των συναρτήσεων.

Για να δοκιμάσουμε την απόδοση του best fit σε σχέση με τον first fit, αναπτύξαμε άλλα δύο system calls, ένα το οποίο δεσμεύει με
kmalloc όσο χώρο του ζητηθεί και ένα που κάνει kfree. Τέλος, αναπτύξαμε ένα user space πρόγραμμα το οποίο κάνει έναν συγκεκριμένο αριθμό
από allocations και free (χρησιμοποιώντας αυτά τα system calls), για ένα συγκεκριμένο αριθμό επαναλήψεων, και τυπώνει μετρήσεις που έχει
λάβει/υπολογίσει από τα system calls.
Συγκεκριμένα, για ITERATIONS αριθμό επαναλήψεων, κάνει ALLOCATIONS αριθμό από allocations των εξής μεγεθών. Εάν έχει επιλεγεί small, 
κάνει allocate που εξυπηρετείται από τη λίστα των <256 bytes (στην περίπτωσή μας επιλέξαμε τα 150). Εάν έχει επιλεγεί medium, 
κάνει allocate που εξυπηρετείται από τη λίστα των >=256 και <1024 bytes (στην περίπτωσή μας επιλέξαμε τα 800). Εάν έχει επιλεγεί larga, 
κάνει allocate που εξυπηρετείται από τη λίστα των >=1024 (στην περίπτωσή μας επιλέξαμε τα 1200). Αφού τα κάνει, λαμβάνει το free και allocated
χώρο από τα syscalls, και κάνει free τα allocations. Πάλι, μετρά το free και το allocated χώρο. Όταν ολοκληρωθούν τα iterations, υπολογίζει τον
μέσο όρο και τυπώνει τα stats.




-------------ΑΠΟΤΕΛΕΣΜΑΤΑ ΔΟΚΙΜΩΝ-------------
~~~~~~~~~
FIRST FIT
~~~~~~~~~

SMALL
AVERAGE AFTER ALLOCATION:
ALLOCATED: 736745
FREE: 3959458

AVERAGE AFTER FREE:
ALLOCATED: 732549
FREE: 3963348



MEDIUM
AVERAGE AFTER ALLOCATION:
ALLOCATED: 748075
FREE: 4176877

AVERAGE AFTER FREE:
ALLOCATED: 724128
FREE: 4177847



LARGE
AVERAGE AFTER ALLOCATION:
ALLOCATED: 766553
FREE: 5146233

AVERAGE AFTER FREE:
ALLOCATED: 726574
FREE: 5143552



~~~~~~~~
BEST FIT
~~~~~~~~

SMALL
AVERAGE AFTER ALLOCATION:
ALLOCATED: 725231
FREE: 2332025

AVERAGE AFTER FREE:
ALLOCATED: 721571
FREE: 2374395



MEDIUM
AVERAGE AFTER ALLOCATION:
ALLOCATED: 744791
FREE: 2220874

AVERAGE AFTER FREE:
ALLOCATED: 720828
FREE: 2217794



LARGE
AVERAGE AFTER ALLOCATION:
ALLOCATED: 762110
FREE: 3453424

AVERAGE AFTER FREE:
ALLOCATED: 722212
FREE: 3352736



----------ΠΑΡΑΤΗΡΗΣΕΙΣ----------
ΣΗΜΕΙΩΣΗ: Όλες οι εκτελέσεις έγιναν σε freshly booted σύστημα, χωρίς να τρέχει τίποτα άλλο πέρα απο τα processes που ξεκινούν στο boot.
Τρέξαμε για 50 επαναλήψεις, με 15000 allocations/frees σε κάθε επανάληψη.

Παρατηρούμε πως η ελεύθερη μνήμη είναι αρκετά μικρότερη στον best fit, όπως και η allocated μνήμη για κάθε μέγεθος. 
Αυτο συμβαίνει γιατί ο best-fit δεν σπαταλά μεγάλα blocks μνήμης για μικρά requests, όπως συμβαίνει με τον first-fit και έτσι γίνονται λιγοτερα page allocations.
Με τον best-fit όμως αν το block δεν είναι ακριβώς όσο και το μέγεθος του request, δημιουργούνται αρκετά μικρα blocks που πιθανώς να μην χρησιμοποιηθούν ποτέ, αυξάνοντας
έτσι τον κατακερματισμό της μνήμης.